<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>llama.route documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Llama-core</span> <span class="project-version">0.1.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="01-intro.html"><div class="inner"><span>Introduction </span></div></a></li><li class="depth-1 "><a href="02-tutorial.html"><div class="inner"><span>Tutorial</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>llama</span></div></div></li><li class="depth-2 branch"><a href="llama.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch current"><a href="llama.route.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>route</span></div></a></li><li class="depth-2"><a href="llama.testing.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>testing</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="llama.route.html#var-add-routes"><div class="inner"><span>add-routes</span></div></a></li><li class="depth-1"><a href="llama.route.html#var-aggregate"><div class="inner"><span>aggregate</span></div></a></li><li class="depth-1"><a href="llama.route.html#var-aggregator"><div class="inner"><span>aggregator</span></div></a></li><li class="depth-1"><a href="llama.route.html#var-context"><div class="inner"><span>context</span></div></a></li><li class="depth-1"><a href="llama.route.html#var-defcontext"><div class="inner"><span>defcontext</span></div></a></li><li class="depth-1"><a href="llama.route.html#var-filter"><div class="inner"><span>filter</span></div></a></li><li class="depth-1"><a href="llama.route.html#var-fn-.3Epredicate"><div class="inner"><span>fn-&gt;predicate</span></div></a></li><li class="depth-1"><a href="llama.route.html#var-fn-.3Eprocessor"><div class="inner"><span>fn-&gt;processor</span></div></a></li><li class="depth-1"><a href="llama.route.html#var-from"><div class="inner"><span>from</span></div></a></li><li class="depth-1"><a href="llama.route.html#var-header"><div class="inner"><span>header</span></div></a></li><li class="depth-1"><a href="llama.route.html#var-process"><div class="inner"><span>process</span></div></a></li><li class="depth-1"><a href="llama.route.html#var-route"><div class="inner"><span>route</span></div></a></li><li class="depth-1"><a href="llama.route.html#var-size"><div class="inner"><span>size</span></div></a></li><li class="depth-1"><a href="llama.route.html#var-start"><div class="inner"><span>start</span></div></a></li><li class="depth-1"><a href="llama.route.html#var-stop"><div class="inner"><span>stop</span></div></a></li><li class="depth-1"><a href="llama.route.html#var-to"><div class="inner"><span>to</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">llama.route</h1><div class="doc"><div class="markdown"><p>A Clojure DSL for <a href="http://camel.apache.org/routes.html">Camel Routes</a>. Provides a framework from routing messages between endpoints.</p>
<h3><a href="#the-dsl" name="the-dsl"></a>The DSL</h3>
<p>The DSL tries to be a close approximation of the <a href="http://camel.apache.org/java-dsl.html">fluent DSL</a>. This namespace provides Clojure translations of the routing DSL.</p>
<p><a href="llama.route.html#var-route">route</a> instantiates a <a href="null">RouteBuilder</a>, which is what you add to a <em>context</em>. These can be added to a context via <a href="llama.route.html#var-defcontext">defcontext</a>, or by calling the method <code>.addRoutes</code> on ctx directly.</p>
<pre><code>;; read from (local) ActiveMQ queue hello, print the body of the incoming
;; message, write the exchange to a file in `dump/fromHello.txt`.
(route (from "activemq:hello")
       (process (fn [x] (println (body (in x)))))
       (to "file:dump?fileName=fromhello.txt"))
</code></pre>
<h3><a href="#running-routes" name="running-routes"></a>Running routes</h3>
<p>After the routes have been added to the context, the context can be started with <a href="llama.route.html#var-start">start</a>. This is a non-blocking operation so if your program is simply doing something with Camel you need an infinite loop of sorts. It is a good idea to <a href="llama.route.html#var-stop">stop</a> the context when your program starts. You could use <a href="https://github.com/stuartsierra/component">component</a> for managing the lifecycle of your program.</p>
<pre><code>(defcontext ctx myroute)
(-defn main [&amp; args]
  (start ctx)
  ;; your app logic here
  (stop ctx))
</code></pre>
<h3><a href="#where-to-start-" name="where-to-start-"></a>Where to start?</h3>
<p>See the <a href="./01-intro.html">Introduction</a>.</p>
<p>It is a good idea to learn what <a href="http://camel.apache.org">Apache Camel</a> is before trying to use Llama. <a href="http://stackoverflow.com/questions/8845186/what-exactly-is-apache-camel">This StackOverflow thread</a> is a good place to start. To grok Llama, you need to understand the following:</p>
<ul>
  <li><a href="http://camel.apache.org/endpoint.html">Endpoints</a> – sources and destinations of messages</li>
  <li><a href="http://camel.apache.org/exchange.html">Exchanges</a> – messagings between two components</li>
  <li><a href="http://camel.apache.org/routes.html">Routes</a> – how to wire exchanges between sources and destinations</li>
</ul>
<p>Once you have a basic understanding of those, you should be able to get going. Alternatively, dive in and <a href="./02-tutorial.html">read the tutorial</a>.</p></div></div><div class="public anchor" id="var-add-routes"><h3>add-routes</h3><div class="usage"><code>(add-routes ctx routes)</code></div><div class="doc"><div class="markdown"><p>Add the routes in <code>routes</code> to <code>ctx</code>.</p></div></div><div class="src-link"><a href="http://github.com/ane/llama/blob/master/src/llama/route.clj#L339">view source</a></div></div><div class="public anchor" id="var-aggregate"><h3>aggregate</h3><h4 class="type">macro</h4><div class="usage"><code>(aggregate expr strat)</code></div><div class="doc"><div class="markdown"><p>Aggregate messages into one message based on a <em>correlation expression</em> and <em>strategy</em>. </p>
<p>The correlation expression identifies how messages should be correlated for aggregation. The strategy defines how the messages should be combined.</p>
<p>When messages messages match the expression, combine them using the provided strategy. The strategy is used to reduce (i.e. fold) the messages into one. The strategy should be a function of two args or a Camel <code>Aggregationstrategy</code>.</p>
<p>The arguments will be the previous and the current exchange, and the value returned should be the new exchange. The condition of the aggregation (amount, time, etc.) can be comined using the completion condition (see below)</p>
<p><strong>Note.</strong> If passing a function as the aggregator, the previous exchange is <code>nil</code>, the new exchange will be returned, since the aggregating fn cannot be called. Override this behaviour by creating your own <code>AggregationStrategy</code> using <a href="llama.route.html#var-aggregate">aggregate</a>.</p>
<p>All of the Camel expressions are supported directly. For a list of expressions, see the Camel documentation <a href="http://camel.apache.org/aggregator2.html">Camel documentation</a>.</p>
<p>And the completion condition can be one of the following macros:</p>
<table>
  <thead>
    <tr>
      <th>Macro </th>
      <th>Usage </th>
      <th>Java API </th>
      <th>Function</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="llama.route.html#var-size">size</a> </td>
      <td><code>(size n)</code> </td>
      <td><code>completionSize</code> </td>
      <td>aggregate <code>n</code> elements together </td>
    </tr>
  </tbody>
</table>
<p>For more information, see the Camel documentation on aggregators.</p>
<pre><code>;; group messages together that have the same value for 
;; the cheese header, wait for three elements, combine their bodies,
;; and send downstream
(route (from "direct:hello")
     (aggregate (header "cheese") 
                (fn [old new] 
                   (set-in old (message (str (body (in old))
                                             (body (in new)))))
                   old))
     (size 3)
     (to "mock:hello"))
</code></pre></div></div><div class="src-link"><a href="http://github.com/ane/llama/blob/master/src/llama/route.clj#L233">view source</a></div></div><div class="public anchor" id="var-aggregator"><h3>aggregator</h3><div class="usage"><code>(aggregator myfn)</code></div><div class="doc"><div class="markdown"><p>Create an aggregation strategy. Takes a fn of two arguments that combines two  exchanges into one. The first exchange may be null when the aggregation  starts, see note. You can use this with <a href="llama.route.html#var-aggregate">aggregate</a>.</p>
<p><strong>Note</strong>. When aggregation gets its first message, its content will be <code>nil</code>. The <a href="llama.route.html#var-aggregate">aggregate</a>  function defaults to returning the first exchange when this happens, but with this behaviour you can  override that behaviour.</p>
<pre><code>(def myagg (aggregator
            (fn [old new] (if-not x1
                          (do
                            (println "First message, skipping!")
                            old)
                          (str (body (in old)) (body (in new)))))))
</code></pre></div></div><div class="src-link"><a href="http://github.com/ane/llama/blob/master/src/llama/route.clj#L299">view source</a></div></div><div class="public anchor" id="var-context"><h3>context</h3><div class="usage"><code>(context)</code><code>(context ctx-or-reg)</code></div><div class="doc"><div class="markdown"><p>Create a CamelContext. Optionally pass a <a href="http://docs.oracle.com/javase/7/docs/api/javax/naming/Context.html?is-external=true">JNDI Context</a> or <a href="http://camel.apache.org/registry.html">Registry</a>.</p></div></div><div class="src-link"><a href="http://github.com/ane/llama/blob/master/src/llama/route.clj#L332">view source</a></div></div><div class="public anchor" id="var-defcontext"><h3>defcontext</h3><h4 class="type">macro</h4><div class="usage"><code>(defcontext name &amp; routes)</code></div><div class="doc"><div class="markdown"><p>Defines <code>name</code> to DefaultCamelContext, adding the <a href="https://static.javadoc.io/org.apache.camel/camel-core/2.18.2/org/apache/camel/builder/RouteBuilder.html">RouteBuilder</a> in <code>routes</code>. Note, the routes won’t start unless the context isn’t already started. Sets <code>nameStragety</code> field of <code>ctx</code> to <code>name</code>. <strong>Remember</strong>, nothing will start unless you call <code>(start name)</code>. See <a href="llama.route.html#var-start">start</a> and <a href="llama.route.html#var-stop">stop</a>.</p>
<pre><code>(defcontext foobar
(route (from "activemq:queue:hi")
       (process (fn [xchg] (println xchg)))
       (to "file:blah")))

(start ctx) ; pump a message to activemq on queue hi, will be printed to *out*
            ; note: this does NOT block! use a loop if you want your program to
            ; run
(stop ctx)  ; shut down
</code></pre></div></div><div class="src-link"><a href="http://github.com/ane/llama/blob/master/src/llama/route.clj#L81">view source</a></div></div><div class="public anchor" id="var-filter"><h3>filter</h3><h4 class="type">macro</h4><div class="usage"><code>(filter pred)</code></div><div class="doc"><div class="markdown"><p>Filter exchanges using <code>pred</code>.</p>
<p>A filter needs a downstream component, like <a href="llama.route.html#var-to">to</a> or <a href="llama.route.html#var-process">process</a>. It would be  pretty useless otherwise, right? Without it, starting the associated context  will blow up during start-up.</p>
<p><code>pred</code> should be an 1-arg function accepting an exchange and returning a boolean, or a Camel  <a href="http://camel.apache.org/predicate.html">Predicate</a>.</p>
<pre><code>(route (from "direct:foo")
       (filter (fn [x] (starts-with? "hello" (body (in x)))))
       (process (fn [x] (println (str "Made it:" (body (in x))))))
       (to "mock:faa"))
</code></pre></div></div><div class="src-link"><a href="http://github.com/ane/llama/blob/master/src/llama/route.clj#L213">view source</a></div></div><div class="public anchor" id="var-fn-.3Epredicate"><h3>fn-&gt;predicate</h3><div class="usage"><code>(fn-&gt;predicate pred)</code></div><div class="doc"><div class="markdown"><p>Turn <code>pred</code> into a Predicate. <code>pred</code> should be a 1 arg function.</p></div></div><div class="src-link"><a href="http://github.com/ane/llama/blob/master/src/llama/route.clj#L205">view source</a></div></div><div class="public anchor" id="var-fn-.3Eprocessor"><h3>fn-&gt;processor</h3><div class="usage"><code>(fn-&gt;processor proc-fn)</code></div><div class="doc"><div class="markdown"><p>Create a <a href="http://camel.apache.org/processor.html">Processor</a> from <code>proc-fn</code>, a fn accepting one argument, an <a href="http://camel.apache.org/exchange.html">Exchange</a>. See <a href="llama.route.html#var-process">process</a>.</p></div></div><div class="src-link"><a href="http://github.com/ane/llama/blob/master/src/llama/route.clj#L63">view source</a></div></div><div class="public anchor" id="var-from"><h3>from</h3><h4 class="type">macro</h4><div class="usage"><code>(from &amp; endpoints)</code></div><div class="doc"><div class="markdown"><p>Read from <code>endpoints</code>. </p>
<p>Must be the first expression inside a <a href="llama.route.html#var-route">route</a> block. Can only be called once in a <a href="llama.route.html#var-route">route</a> block.</p>
<p>Each endpoint in <code>endpoints</code> can be a collection of either <a href="http://camel.apache.org/uris.html">Camel URIs</a> or an <a href="http://camel.apache.org/endpoint.html">Endpoints</a>.</p>
<p>You need to have the Camel component in the classpath. For example, <code>rabbitmq://</code> requires the RabbitMQ component, available in <code>camel-rabbitmq</code>, <code>activemq:...</code> requires ActiveMQ and so on.</p>
<p>Makes the <code>RouteBuilder</code> defined in <a href="llama.route.html#var-route">route</a> to read from <code>endpoint</code>. Binds <code>this</code> to a <code>RouteDefinition</code> so that calls to <a href="llama.route.html#var-to">to</a> and <a href="llama.route.html#var-process">process</a> will work. You can call the <a href="https://static.javadoc.io/org.apache.camel/camel-core/2.18.2/org/apache/camel/model/RouteDefinition.html">methods</a> of <code>this</code> to alter its behaviour. See <a href="llama.route.html#var-route">route</a>.</p>
<pre><code>;; will aggregate data from thee endpoints, printing the exchanges
(route (from "vm:foo" "direct:hello" "activemq:queue:bar")
       (process (fn [x] (println x))))
</code></pre></div></div><div class="src-link"><a href="http://github.com/ane/llama/blob/master/src/llama/route.clj#L130">view source</a></div></div><div class="public anchor" id="var-header"><h3>header</h3><h4 class="type">macro</h4><div class="usage"><code>(header name)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="http://github.com/ane/llama/blob/master/src/llama/route.clj#L290">view source</a></div></div><div class="public anchor" id="var-process"><h3>process</h3><h4 class="type">macro</h4><div class="usage"><code>(process p)</code></div><div class="doc"><div class="markdown"><p>Add <code>p</code> as a processing step to this <code>RouteDefinition</code>. Useful for transforming a message before sending it forward with <a href="llama.route.html#var-to">to</a>, or to replying to it with <a href="llama.core.html#var-reply">reply</a>. Must be invoked after a call to <a href="llama.route.html#var-from">from</a>. </p>
<p>See also <a href="llama.core.html#var-in">in</a>, <a href="llama.core.html#var-out">out</a>, <a href="llama.core.html#var-set-in">set-in</a> and <a href="llama.core.html#var-set-out">set-out</a>.</p>
<p><code>p</code> can be a one argument fn accepting an fn accepting one argument or a Processor. See <a href="llama.route.html#var-fn-.3Eprocessor">fn-&gt;processor</a>. Keep in mind, altering the exchange will affect subsequent inputs <a href="llama.route.html#var-to">to</a>, <a href="llama.route.html#var-filter">filter</a>, <a href="llama.route.html#var-process">process</a> calls.</p>
<pre><code>;; creates a Jetty HTTP server
;; get in -&gt; get body -&gt; reverse -&gt; print
(route (from "jetty://localhost:33221/hello")
       (process (comp println clojure.string/reverse body in))
       (to "log:hello")
</code></pre></div></div><div class="src-link"><a href="http://github.com/ane/llama/blob/master/src/llama/route.clj#L183">view source</a></div></div><div class="public anchor" id="var-route"><h3>route</h3><h4 class="type">macro</h4><div class="usage"><code>(route &amp; routes)</code></div><div class="doc"><div class="markdown"><p>Build a Camel <a href="http://camel.apache.org/routes.html">Route</a>, using <a href="llama.route.html#var-from">from</a>, <a href="llama.route.html#var-to">to</a>, <a href="llama.route.html#var-process">process</a> etc.</p>
<p>An expression of <code>(route (from a) (foo b) (xyz) (bar baz bax))</code> maps directly to a Java equivalent of <code>.from(a).foo(b).xyz().bar(baz, bax)</code>.</p>
<p>Binds <code>this</code> to a <code>RouteBuilder</code>, using the definitions in <code>routes</code>. The first element in <code>route</code> should be a call to <a href="llama.route.html#var-from">from</a>, followed by either <a href="llama.route.html#var-process">process</a> or <a href="llama.route.html#var-to">to</a>. Note, adding a route with just a from, i.e., an empty <code>rest</code>, results an error when you start the context.</p>
<pre><code>(route 
  (from "activemq:queue:hi")
  (process (fn [x] (println x)))
  (to "rabbitmq:blah"))
</code></pre></div></div><div class="src-link"><a href="http://github.com/ane/llama/blob/master/src/llama/route.clj#L107">view source</a></div></div><div class="public anchor" id="var-size"><h3>size</h3><h4 class="type">macro</h4><div class="usage"><code>(size n)</code></div><div class="doc"><div class="markdown"><p>Used with <a href="llama.route.html#var-aggregate">aggregate</a>. Expect <code>n</code> items in aggregation.</p></div></div><div class="src-link"><a href="http://github.com/ane/llama/blob/master/src/llama/route.clj#L294">view source</a></div></div><div class="public anchor" id="var-start"><h3>start</h3><div class="usage"><code>(start ctx)</code></div><div class="doc"><div class="markdown"><p>Starts <code>ctx</code>, does not block.</p></div></div><div class="src-link"><a href="http://github.com/ane/llama/blob/master/src/llama/route.clj#L322">view source</a></div></div><div class="public anchor" id="var-stop"><h3>stop</h3><div class="usage"><code>(stop ctx)</code></div><div class="doc"><div class="markdown"><p>Stops <code>ctx</code>, shutting down all routes that go along with it.</p></div></div><div class="src-link"><a href="http://github.com/ane/llama/blob/master/src/llama/route.clj#L327">view source</a></div></div><div class="public anchor" id="var-to"><h3>to</h3><h4 class="type">macro</h4><div class="usage"><code>(to &amp; endpoints)</code></div><div class="doc"><div class="markdown"><p>Send data to <code>endpoints</code>.</p>
<p>Can be chained multiple times at any point after <a href="llama.route.html#var-from">from</a>.</p>
<p>Each endpoint in <code>endpoints</code> can be a collection of either <a href="http://camel.apache.org/uris.html">Camel  URIs</a> or  an <a href="http://camel.apache.org/endpoint.html">Endpoints</a>.</p>
<p>See the note about components in the docs for <a href="llama.route.html#var-from">from</a>.</p>
<p>Adds <code>endpoints</code>, Endpoints or String URI, to the <code>RouteDefinition</code>, sending  exchanges to those endpoints. Must be after a <a href="llama.route.html#var-from">from</a>. See <a href="llama.route.html#var-route">route</a>.</p>
<pre><code>(route (from "activemq:hello")
       (to "file:blaa")
       (to "kafka:topic:bar"))
</code></pre></div></div><div class="src-link"><a href="http://github.com/ane/llama/blob/master/src/llama/route.clj#L159">view source</a></div></div></div></body></html>